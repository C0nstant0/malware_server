#include <WinSock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#include <vector>
#include <thread>
#include <iostream>

#pragma comment (lib, "ws2_32.lib")

using namespace std;

#define BUFFERSIZE 1024


void client_operation(SOCKET clientSock, SOCKADDR_IN clientAddr, vector<thread*>* clientlist);
char* print(vector<char>* str);



int main()
{
	vector<thread*> clientlist;

	//winSock 라이브러리 초기화
	WSADATA data;
	::WSAStartup(MAKEWORD(2, 2), &data);

	// 소켓 생성 하는 부분
	SOCKET server = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (server == INVALID_SOCKET) {
		cout << "server fail" << endl;
		return -1;
	}

	// 바인딩 하는 부분
	SOCKADDR_IN addr = { 0 };

	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
	addr.sin_port = htons(8888);

	if (bind(server, (sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) {
		cout << "Bind Error" << endl;
		return -1;
	}

	// 연결 대기하는 곳
	if (listen(server, SOMAXCONN) == SOCKET_ERROR) {
		cout << "listen Error" << endl;
		return -1;
	}
	cout << "Server Start! " << endl;


	// 연결 수락
	SOCKET client = accept(server, NULL, NULL);
	closesocket(client);

	while (1)
	{
		// 접속 설정 구조체 사이즈
		int len = sizeof(SOCKADDR_IN);
		// 접속 설정 구조체
		SOCKADDR_IN clientAddr;
		// client가 접속을 하면 SOCKET을 받는다.
		SOCKET client = accept(server, (SOCKADDR*)&clientAddr, &len);
		// 쓰레드를 실행하고 쓰레드 리스트에 넣는다.
		clientlist.push_back(new thread(client_operation, client, clientAddr, &clientlist));
	}
	// 종료가 되면 쓰레드 리스트에 남아 있는 쓰레드를 종료할 때까지 기다린다.
	for (auto ptr = clientlist.begin(); ptr < clientlist.end(); ptr++)
	{
		(*ptr)->join();
	}

	// 소켓 종료
	closesocket(server);
	::WSACleanup();

}


// 접속되는 client별 쓰레드
void client_operation(SOCKET clientSock, SOCKADDR_IN clientAddr, vector<thread*>* clientlist)
{
	// 접속 정보를 콘솔에 출력한다.
	char clientIP[20] = { 0 };
	inet_ntop(AF_INET, &clientAddr.sin_addr, clientIP, sizeof(clientIP));
	cout << "Client connected IP address = " << clientIP << ":" << ntohs(clientAddr.sin_port) << endl;
	// client로 메시지를 보낸다.
	const char* message = "Welcome server!\r\n>\0";
	send(clientSock, message, strlen(message) + 1, 0);
	// telent은 한글자씩 데이터가 오기 때문에 글자를 모을 buffer가 필요하다.
	vector<char> buffer;
	// 수신 데이터
	char x;
	while (1)
	{
		// 데이터를 받는다. 에러가 발생하면 멈춘다.
		if (recv(clientSock, &x, sizeof(char), 0) == SOCKET_ERROR)
		{
			// 에러 콘솔 출력
			cout << "error" << endl;
			break;
		}
		// 만약 buffer의 끝자리가 개행일 경우
		if (buffer.size() > 0 && *(buffer.end() - 1) == '\r' && x == '\n')
		{
			// 메시지가 exit일 경우는 수신대기를 멈춘다.
			if (*buffer.begin() == 'e' && *(buffer.begin() + 1) == 'x' && *(buffer.begin() + 2) == 'i' && *(buffer.begin() + 3) == 't') {
				break;
			}
			// 콘솔에 출력하고 에코 메시지를 받는다.
			const char* echo = print(&buffer);
			// client로 에코 메시지 보낸다.
			send(clientSock, echo, buffer.size() + 10, 0);
			// 에코 메시지를 힙(new을 사용한 선언)에 선언했기 때문에 메모리 해지한다.
			delete echo;
			// 버퍼를 비운다.
			buffer.clear();
			// 다음 메시지 수신 대기
			continue;
		}
		// 버퍼에 글자를 하나 넣는다.
		buffer.push_back(x);
	}
	// 수신 대기가 끝나면 client와 소켓 통신을 끊는다.
	closesocket(clientSock);
	// 접속 정보를 콘솔에 출력한다.

	cout << "Client disconnected IP address = " << clientIP << ":" << ntohs(clientAddr.sin_port) << endl;
	// threadlist에서 현재 쓰레드를 제거한다.
	for (auto ptr = clientlist->begin(); ptr < clientlist->end(); ptr++)
	{
		// thread 아이디가 같은 것을 찾아서
		if ((*ptr)->get_id() == this_thread::get_id())
		{
			// 리스트에서 뺀다.
			clientlist->erase(ptr);
			break;
		}
	}
	// thread 메모리 해지는 thread가 종료 됨으로 자동으로 처리된다.
}




char* print(vector<char>* str)
{
	// 포인트 위치
	int p = 0;
	// 버퍼 설정. +1은 \0를 넣기 위한 크기
	char out[BUFFERSIZE + 1];
	// return을 하기 위해서는 힙에 데이터를 선언 해야 한다.
	char* ret = new char[str->size() + 10];
	// 메모리 복사 "echo - "를 붙힌다.
	memcpy(ret, "echo - ", 7);
	// 콘솔 출력
	cout << "From Client message : ";
	// buffer사이지를 넘어서는 데이터일 경우 반복을 통해서 받는다.
	for (int n = 0; n < (str->size() / BUFFERSIZE) + 1; n++)
	{
		// 버퍼 사이즈 설정
		int size = str->size();
		// 수신 데이터가 버퍼 사이즈를 넘었을 경우.
		if (size > BUFFERSIZE) {
			if (str->size() < (n + 1) * BUFFERSIZE)
			{
				size = str->size() % BUFFERSIZE;
			}
			else
			{
				size = BUFFERSIZE;
			}
		}
		// echo 메시지와 콘솔 메시지를 작성한다.
		for (int i = 0; i < size; i++, p++)
		{
			out[i] = *(str->begin() + p);
			if (out[i] == '\0')
			{
				out[i] = ' ';
			}
			*(ret + p + 7) = out[i];
		}
		out[size] = '\0';
		// 콘솔 메시지 콘솔 출력.
		cout << out;
	}
	cout << endl;
	// 에코 메시지는 끝에 개행 + ">"를 넣는다.
	memcpy(ret + p + 7, "\n>\0", 3);
	return ret;
}